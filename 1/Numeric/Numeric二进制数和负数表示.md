# 二进制数和负数表示

## 一、二进制数的表示

- **自然数的二进制表示**：
  - 自然数可以直接用二进制表示。例如，用 8 位表示 255 时为 `1111 1111`。

## 二、负数表示的方法

### 1. 符号-数值法 (Signed Magnitude)

- **表示方法**：使用最高位来表示符号，`0` 表示正数，`1` 表示负数。
- **示例**：
  - 42 的二进制为 `0010 1010`
  - -42 的二进制为 `1010 1010`
  - 79 的二进制为 `0100 1111`
  - -79 的二进制为 `1100 1111`
- **范围**：
  - 使用 8 位表示的数值范围为 -127 到 127。
- **问题**：
  - **0 的表示重复**：存在两个 0 的表示方法：`0000 0000` 和 `1000 0000`。
  - **算术运算不总是有效**：在加减法运算中可能会产生错误。

### 2. 二进制补码 (Two's Complement)

- **正数表示**：直接使用标准的二进制表示。
- **负数表示**：
  - 获取正数的二进制表示后，将每一位取反（0 变 1，1 变 0），然后加 1。
- **为什么取反加 1 有效？**
  - 举例：+4 的二进制为 `0000 0100`，-4 的补码为 `1111 1100`。
  - 计算：当 +4 和 -4 相加时，结果应为 0，即 `0000 0000`。
- **补码运算示例**：
  - `0000 0100` (4) + `1111 1100` (-4) = `0000 0000`

### 3. 检查溢出

- **进位检查**：在执行二进制加法时，检查最高位的进位以判断是否发生溢出。
- **示例**：
  - 使用 8 位补码表示时，`-79 + 55` 没有溢出，结果为 `-24`。
  - `-79 - 88` 产生溢出，因为超出了 8 位补码的表示范围。

## 三、位数需求计算

- 计算表示特定数值所需的最小位数。
- 例如，要在补码中表示 2100：
  - 需要 13 位（12 位用于表示大小，1 位用于表示符号）。

---

## 补码（Two's Complement）详解

补码在计算机系统中广泛用于表示带符号的整数，特别是用于表示负数。它的优势在于简化了计算操作，使得加减法更为高效。以下是补码的详细解释和相互转换的步骤。

---

### 什么是补码？

补码是二进制数的一种表示方式，用于表示带符号的整数，特别适合计算机内部的数值计算。

- **正数的补码**：与原码相同。
- **负数的补码**：取正数的二进制表示，取反（所有位 0 变 1，所有位 1 变 0），再加 1。

例如，对于 8 位的表示：

- \( 5 \) 的二进制是 `0000 0101`。
- \( -5 \) 的补码是 `1111 1011`。

---

### 补码表示的范围

对于 \( n \) 位的补码数，表示范围为 \(-2^{(n-1)}\) 到 \(2^{(n-1)} - 1\)。

例如，对于 8 位补码：

- 最小值是 \(-128\)（`1000 0000`）
- 最大值是 \(127\)（`0111 1111`）

---

### 正数与负数的补码表示

#### 1. 正数的补码

- 直接使用正数的二进制表示，不做任何更改。

#### 2. 负数的补码

- 先将对应的正数转成二进制。
- 对每一位取反（0 变 1，1 变 0）。
- 在取反后的结果上加 1。

---

### 补码的相互转换

#### 从正数到负数（补码）

1. **将正数转换为二进制**：如 \(5\) 的二进制表示是 `0000 0101`。
2. **对二进制取反**：将 `0000 0101` 的每一位取反，得到 `1111 1010`。
3. **加 1**：在 `1111 1010` 上加 1，得到 `1111 1011`，即是 \(-5\) 的补码表示。

#### 从负数到正数（补码）

1. **减 1**：如 `1111 1011` 表示 \(-5\)，先减 1 得到 `1111 1010`。
2. **取反**：将 `1111 1010` 的每一位取反，得到 `0000 0101`，即是 \(5\) 的二进制。

---

### 示例讲解

**示例 1**：将 \( -42 \) 表示为补码

1. **将 42 转换为二进制**：`0010 1010`
2. **取反**：`1101 0101`
3. **加 1**：`1101 0101 + 1 = 1101 0110`

所以，\( -42 \) 的 8 位补码表示是 `1101 0110`。

**示例 2**：将补码 `1101 0110` 转换回十进制

1. **减 1**：`1101 0110 - 1 = 1101 0101`
2. **取反**：`1101 0101` 取反为 `0010 1010`，对应的十进制为 \(42\)。
3. 因为补码是以 1 开头，表示是负数，因此结果是 \( -42 \)。

---

### 为什么补码有效？

补码的表示方式使得加法和减法运算可以在不考虑符号的情况下进行，这大大简化了计算过程。例如：

- 对于 8 位二进制，\(5\) 表示为 `0000 0101`，\(-5\) 表示为 `1111 1011`。
- 两者相加会得到 `0000 0000`，符合加减法的运算规则。

---

### 常见的补码操作

#### 1. 补码加法

补码加法可以直接在二进制位上进行，不需要关心符号位。例如 \(5 + (-3)\)：

- \(5\) 的补码是 `0000 0101`。
- \(-3\) 的补码是 `1111 1101`。

相加：`0000 0101 + 1111 1101 = 0000 0000`。

#### 2. 溢出检查

由于补码的范围有限，可能会出现溢出。当最高位进位发生变化时，可能表示了溢出。例如 8 位补码中，当加法结果超出 \(-128\) 到 \(127\) 的范围时，就发生溢出。

---

补码的转换在计算机系统中广泛应用，尤其是在处理有符号整数时。理解补码的转换规则后，可以更好地理解计算机如何进行二进制运算和错误检查。

# 为什么叫做“补码（Two's Complement）”

**补码**之所以得名，是因为它在二进制中使用了“补到 2”的概念来表示负数。“Two”的意思是指**二进制**（base-2）系统。以下是详细解释。

## 1. “补”的含义

在数学中，**补（complement）**通常指“补到某个值”。在十进制系统中，"9 的补码"表示补到 9 的差。例如：

- 对于数字 3，它的 9 的补码是 6，因为 \( 3 + 6 = 9 \)。

在二进制中，概念类似。**补码方法**的核心在于把一个数“补”到 2 的幂，从而得到一种独特的负数表示方法。

## 2. 为什么叫做“二的补码（Two's Complement）”

在二进制系统中表示负数时，有两种常用的方法：**一的补码（One's Complement）**和**二的补码（Two's Complement）**。

- **一的补码**：将每一位取反（0 变 1，1 变 0）。
- **二的补码**：先求一的补码，然后加 1。

**二的补码实际上是把一个数补到 2 的幂**。对于一个 n 位的二进制数，二的补码是补到 \(2^n\)。这种表示方式让二进制系统能够干净地表示负数，避免了重复表示 0 等问题，因此被称为“二的补码”。

## 3. 补码的数学意义

在二进制中，计算一个数的二的补码的步骤是：

1. 将该数的二进制表示每一位取反（得到一的补码）。
2. 对取反后的结果加 1。

这种方法使得补码成为计算和表示负数的一种自然方式，便于二进制运算和计算机处理。

### 8 位二进制数的表示方式

这张图展示了**8 位二进制数（8 bits）**在不同表示系统中的转换流程：

1. **8 bits**：指的是一个 8 位的二进制数，可以表示成二进制或十六进制。

2. **hex（十六进制）**：8 位二进制数可以转换成十六进制表示，每 4 位二进制数对应 1 位十六进制数。例如，`1111 1111` 在十六进制中表示为 `FF`。

3. **binary（二进制）**：8 位二进制数可以直接表示为二进制数，便于进行二进制运算和逻辑处理。

4. **signed（有符号）和 unsigned（无符号）**：
   - **Signed**：表示带符号的数，其中最左边的一位用来表示符号（0 表示正，1 表示负）。8 位带符号数的范围是 -128 到 127。
   - **Unsigned**：表示无符号的数，所有 8 位都用于表示数值。8 位无符号数的范围是 0 到 255。

总结来说，这张图说明了 8 位二进制数在不同进制和有符号/无符号表示方式之间的转换关系。

### 4 位二进制数的范围及溢出问题

#### 二进制表示

- 4 位二进制数的最大值为 `0111`，对应十进制数 **7**。
- 4 位二进制数可以表示的范围（无符号数）为 `0` 到 `2^4 - 1`，即 **0 到 15**。

#### 有符号和无符号表示

- **无符号数**：范围为 `[0, 2^n - 1]`，即 `[0, 15]`。
- **有符号数**：范围为 `[-2^(n-1), 2^(n-1) - 1]`，即 `[-8, 7]`。

#### 有符号数的二进制表示（4 位）

- `0111` 为十进制的 **7**。
- `1001` 表示为 **-7**。
- `1000` 表示为 **-8**。

#### 计算机运算的局限性

- 计算机使用二进制进行运算，这种表示方式存在一些局限性。
- 由于位数有限，会导致**溢出**问题。

#### 溢出检查

1. **范围检查**：确保结果在有效的表示范围内。
2. **符号检查**：如果两个正数相加结果为负数，或两个负数相加结果为正数，说明发生溢出。
3. **8 位溢出检查**：对于 8 位的二进制表示，可以通过检查符号位的一致性来判断溢出。

#### 总结

- 计算机的二进制表示在处理整数时有范围和溢出限制，尤其是在有限位数情况下（如 4 位或 8 位）。

### 二进制运算与溢出检查

#### 计算以下运算的结果（使用 8 位二进制补码表示）

要求：直接从 8 位二进制补码中计算以下操作：`-79 + 55`，`-79 - 88`，以及 `83 + 55`。检查结果是否溢出。

> **注意**：使用上面给出的二进制补码表示进行计算。

---

#### 解答

1. **计算 `-79 + 55`**

   - **补码表示**：
     
     $-79 = 10101111 \quad (二进制)$
     $55 = 00110111 \quad (二进制)$ 
     

   - **相加**：

     10101111 + 00110111 = 11100110

   - **结果**：
     转换回十进制，`11100110` 表示 `-24`。没有发生溢出。

---

2. **计算 `-79 - 88`**

   - **补码表示**：

     $-79 = 10101111 \quad (二进制)$ 
     $-88 = 10101000 \quad (二进制)$

   - **相加**：

     10101111 + 10101000 = 01011001

   - **结果**：
     转换回十进制，`01011001` 不等于正确的值 `-167`，因此发生了 **溢出**。

---

3. **计算 `83 + 55`**

   - **补码表示**：

     $83 = 01010011 \quad (二进制) \\
     55 = 00110111 \quad (二进制) $

   - **相加**：

     01010011 + 00110111 = 10001010

   - **结果**：
     转换回十进制，`10001010` 不等于正确的值 `138`，因此发生了 **溢出**。

---

### 问题 v. 表示 2100 的最小位数

**解答**：需要多少位数才能用二进制补码表示 2100？

- 需要 13 位。
  $2^{11} - 1 = 2047 < 2100 \leq 4095 = 2^{12} - 1$

  因此，需要 12 位来表示数值的大小，再加 1 位作为符号位。