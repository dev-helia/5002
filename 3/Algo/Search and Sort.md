


---

### **Big O 复杂度及常见算法分析表**

|**算法名称**|**时间复杂度**|**适用场景**|**示例算法**|
|---|---|---|---|
|**线性查找 (Linear Search)**|O(n)O(n)|未排序数据查找|遍历一个数组找目标值|
|**二分查找 (Binary Search)**|O(log⁡n)O(\log n)|已排序数据查找|查找目标值在有序数组的位置|
|**插入排序 (Insertion Sort)**|O(n2)O(n^2)|小规模或几乎有序的数据排序|对部分有序的数组排序|
|**选择排序 (Selection Sort)**|O(n2)O(n^2)|简单实现的小规模排序|找到数组中的最小值并交换|
|**归并排序 (Merge Sort)**|O(nlog⁡n)O(n \log n)|大规模数据的高效排序|对列表进行分治法排序|

---

### **渐进复杂度分类与示例**

|**复杂度**|**增长速度**|**示例场景**|
|---|---|---|
|O(1)O(1)|常数级|直接访问数组某个元素。|
|O(log⁡n)O(\log n)|对数级|二分查找、平衡二叉树的查找操作。|
|O(n)O(n)|线性级|遍历一个列表、线性查找。|
|O(nlog⁡n)O(n \log n)|线性对数级|归并排序、快速排序的平均情况。|
|O(n2)O(n^2)|平方级|冒泡排序、选择排序、插入排序的最坏情况。|
|O(2n)O(2^n)|指数级|求解所有可能子集的递归算法。|

---

### **常见递归公式展开思路**

1. **递归公式**：明确递归的核心公式（如 T(n)=aT(n/b)+f(n)T(n) = aT(n/b) + f(n)）。
2. **递归展开**：逐步展开 T(n)T(n)，将问题规模分解并简化公式。
3. **终止条件**：找到递归终止的情况（如 T(1)=1T(1) = 1）。
4. **主定理求解**：利用主定理，确定公式的复杂度范围。

---

# Linear Search

线性搜索（Linear Search）是一种简单的搜索算法。它从数据结构的第一个元素开始，逐个检查每个元素，直到找到目标元素为止。线性搜索在无序或有序的列表中都可以使用，但对于无序列表更常用。虽然效率较低（尤其是在大数据集里），但实现简单且适用广泛。

让我们一步步来看一下线性搜索的思路和实现。

##### 线性搜索的步骤
1. **从头开始**：从列表的第一个元素开始，依次检查每个元素。
2. **逐个对比**：检查当前元素是否等于目标值。
3. **找到目标或到达结尾**：
   - 如果找到目标值，返回其索引（或者标记为“已找到”）。
   - 如果到达列表末尾仍未找到，说明目标值不在列表中。

##### 线性搜索的代码实现（Python）

我们先来看一个基本的实现，然后可以一起讨论它的效率或如何改进：

```python
def linear_search(arr, target):
    for index, value in enumerate(arr):
        if value == target:
            return index  # 返回目标值的索引
    return -1  # 如果目标值不在数组中，返回 -1
```

##### 代码示例的解释
- `for index, value in enumerate(arr)`：遍历列表 `arr`，`index` 表示当前的索引，`value` 是当前的值。
- `if value == target`：检查当前的值是否等于目标值 `target`。
- `return index`：如果找到目标值，返回其索引。
- `return -1`：如果遍历完整个列表都没找到目标值，则返回 -1。

##### 复杂度分析
- **时间复杂度**：线性搜索的时间复杂度为 \(O(n)\)，因为在最坏情况下，需要检查所有元素。
- **空间复杂度**：只需常数级别的额外空间 \(O(1)\)。

##### 练习
可以试着运行一下这个代码，自己写一个包含几个数字的列表，然后查找一个目标值，看看是否能找到它。

- **时间复杂度**：$O(n)$
- **描述**：线性查找在最坏情况下需要进行 n 次比较（即目标元素在末尾或不存在）。
- **适用情况**：数据未排序的情况下可以使用，但性能相对较低。

---

# Binary Search

> [!WARNING]
>
> 注意,数组必须是有序的.


在进行二分查找时，每一步都将搜索范围缩小为之前的一半。假设初始数据规模为 $n$，则每一轮迭代后的规模变化如下：
- 初始规模：$n$
- 第一轮：$\frac{n}{2}$
- 第二轮：$\frac{n}{2^2}$
- 第三轮：$\frac{n}{2^3}$
- ...
- 第 $k$ 轮：$\frac{n}{2^k}$

二分查找继续缩小范围，直到搜索区间缩小到 $1$，即：

$\\frac{n}{2^k} = 1$

#### 求解迭代次数 $k$

==为了找到使 $\frac{n}{2^k} = 1$ 成立的 $k$ 值==，我们可以通过等式变换：
$n = 2^k$

对该等式两边取对数（以 2 为底）： $k = \log_2 n$

因此，==二分查找的时间复杂度为 $O(\log_2 n)$，也即每次迭代搜索区间都会缩小为原来的一半，导致算法的执行次数为 $\log_2 n$ 级别==。

##### 总结

- **时间复杂度**：$O(\log n)$
- **适用条件**：数据需要是已排序的。
- **优点**：在大规模有序数据中查找效率很高，每次查找将问题规模缩小一半。
- **迭代次数**：$\log_2 n$（约为 $\log_2 n$ 次迭代便可确定目标元素的位置或确认其不存在）。


---

# 插入排序（Insertion Sort）
![alt text](插入排序.jpeg)

- **时间复杂度**：最坏情况下为 $O(n^2)$

- **描述**：==插入排序通过将每个新元素插入到已排序部分的正确位置来构建有序序列。==

  

#### 示例列表
初始未排序的列表：`[8, 7, 5, 4, 6, 2, 3, 1]`

#### 排序步骤

插入排序通过每次将一个元素插入到已排序的部分，逐步扩大已排序部分，直到整个列表有序。以下是每一步操作：

1. **[8, 7, 5, 4, 6, 2, 3, 1]**
   - 第一位 8 单独作为有序部分，不需要移动。
   - **1 比较，1 次交换**

2. **[7, 8, 5, 4, 6, 2, 3, 1]**
   - 插入 7 到 8 前面。
   - **2 次比较，2 次交换**

3. **[5, 7, 8, 4, 6, 2, 3, 1]**
   - 插入 5 到 7 和 8 之前。
   - **3 次比较，3 次交换**

4. **[4, 5, 7, 8, 6, 2, 3, 1]**
   - 插入 4 到 5、7 和 8 之前。
   - **3 次比较，2 次交换**

5. **[4, 5, 6, 7, 8, 2, 3, 1]**
   - 插入 6 到 7 之前。
   - **5 次比较，5 次交换**

6. **[2, 4, 5, 6, 7, 8, 3, 1]**
   - 插入 2 到开头。
   - **6 次比较，5 次交换**

7. **[2, 3, 4, 5, 6, 7, 8, 1]**
   - 插入 3 到 4 之前。
   - **7 次比较，6 次交换**

8. **[1, 2, 3, 4, 5, 6, 7, 8]**
   - 插入 1 到开头，列表完成排序。
   - **7 次比较，7 次交换**

#### 时间复杂度分析

插入排序的时间复杂度通常为 \(O(n^2)\)，其中 \(n\) 为列表长度。

##### 比较和交换操作总和

- 假设列表长度为 \(n\)，每次插入的操作次数为从 1 到 \(n\) 的累加和。
- 累加公式：$\sum_{i=1}^{n} i = \frac{n(n+1)}{2}$
- 简化得：$\approx \frac{n^2}{2}$

因此，插入排序的时间复杂度为 \(O(n^2)\)，适用于小型或部分有序的数据集。

---

# 选择排序（Selection Sort）

![alt text](选择排序.jpeg)

- **时间复杂度**：始终为 $O(n^2)$，不依赖数据是否有序。
- **描述**：==选择排序每次在未排序部分中选择最小的元素，放到已排序部分的末尾。互相交换.==

##### 示例列表

初始未排序的列表：`[8, 7, 5, 4, 6, 2, 3, 1]`

##### 排序步骤

选择排序的核心思想是每次找到未排序部分的最小值并将其放到当前排序部分的末尾。以下是每一步操作的具体过程：

1. **[8, 7, 5, 4, 6, 2, 3, 1]**
   - 找到列表中的最小值 1，并将其与第一个元素 8 交换。
   - 得到列表 `[1, 7, 5, 4, 6, 2, 3, 8]`

2. **[1, 7, 5, 4, 6, 2, 3, 8]**
   - 从第二个元素开始，找到未排序部分的最小值 2，将其与 7 交换。
   - 得到列表 `[1, 2, 5, 4, 6, 7, 3, 8]`

3. **[1, 2, 5, 4, 6, 7, 3, 8]**
   - 从第三个元素开始，找到未排序部分的最小值 3，将其与 5 交换。
   - 得到列表 `[1, 2, 3, 4, 6, 7, 5, 8]`

4. **[1, 2, 3, 4, 6, 7, 5, 8]**
   - 从第四个元素开始，找到未排序部分的最小值 4，不需要交换。
   - 列表保持 `[1, 2, 3, 4, 6, 7, 5, 8]`

5. **[1, 2, 3, 4, 6, 7, 5, 8]**
   - 从第五个元素开始，找到未排序部分的最小值 5，将其与 6 交换。
   - 得到列表 `[1, 2, 3, 4, 5, 7, 6, 8]`

6. **[1, 2, 3, 4, 5, 7, 6, 8]**
   - 从第六个元素开始，找到未排序部分的最小值 6，将其与 7 交换。
   - 得到列表 `[1, 2, 3, 4, 5, 6, 7, 8]`

7. **[1, 2, 3, 4, 5, 6, 7, 8]**
   - 剩余元素 7 和 8 已经在正确位置上，排序完成。

##### 时间复杂度分析

选择排序的时间复杂度通常为 \(O(n^2)\)，其中 \(n\) 为列表长度。

##### 比较操作总和

- 在每一轮选择操作中，需要进行 \(n-1\)、\(n-2\)、...、1 次比较，总比较次数为：$\sum_{i=1}^{n} (n-i) = \frac{n(n-1)}{2}$
- 因此，选择排序的时间复杂度为 \(O(n^2)\)，同样适用于小型数据集或对稳定性要求不高的场景。

---

# 归并排序（Merge Sort）

归并排序是一种分治法排序算法，它将数组分成两半分别排序，然后再将结果合并。其主要步骤包括“分割”和“合并”。

> [!IMPORTANT]
>
> 难点.

![alt text](归并排序1.jpeg)

#### 示例列表
初始未排序的列表：`[8, 4, 6, 2, 7, 3, 5, 1]`

#### 排序步骤

1. **分割 (Divide)**：将列表递归地分成两半，直到每部分只有一个元素为止。
   - `T(n)` 表示列表长度为 \( n \) 的情况。
   - 初始列表 `T(n)`: `[8, 4, 6, 2, 7, 3, 5, 1]`
     - 分成 `[8, 4, 6, 2]` 和 `[7, 3, 5, 1]`
   - 再继续分割：
     - `[8, 4]` 和 `[6, 2]`
     - `[7, 3]` 和 `[5, 1]`
   - 进一步分割到单个元素：
     - `[8]`, `[4]`, `[6]`, `[2]`, `[7]`, `[3]`, `[5]`, `[1]`

2. **合并 (Merge)**：将分割的部分逐层合并并排序。
   - 合并 `[8]` 和 `[4]` 得到 `[4, 8]`
   - 合并 `[6]` 和 `[2]` 得到 `[2, 6]`
   - 合并 `[7]` 和 `[3]` 得到 `[3, 7]`
   - 合并 `[5]` 和 `[1]` 得到 `[1, 5]`
   - 继续合并：
     - 合并 `[4, 8]` 和 `[2, 6]` 得到 `[2, 4, 6, 8]`
     - 合并 `[3, 7]` 和 `[1, 5]` 得到 `[1, 3, 5, 7]`
   - 最后，合并 `[2, 4, 6, 8]` 和 `[1, 3, 5, 7]` 得到排序完成的列表 `[1, 2, 3, 4, 5, 6, 7, 8]`

  ![alt text](归并排序2.jpeg)

#### 时间复杂度分析

归并排序的时间复杂度通常为 \(O(n \log n)\)，其中 \(n\) 为列表长度。

归并排序的时间复杂度递推公式是 \( T(n) = 2T\left(\frac{n}{2}\right) + n \)，这个公式源于归并排序的**分治策略**，即每次把问题分成两个子问题解决，然后合并结果。我们可以从两个方面来理解这个公式：

1. 分治策略中的**分解**过程

- 归并排序采用“分而治之”的方法，将数组分成左右两部分，分别对左右部分进行排序。
- **每次递归调用把数组分成两半**，这样总共有两次递归调用，处理的子数组大小为 \(\frac{n}{2}\)。
- 因此，分解的过程可以看成是递归调用两次 `T(n/2)`。

2. 分治策略中的**合并**过程

- 在每一级的递归完成之后，我们需要将两个已经排好序的子数组合并成一个有序的数组。
- 合并的过程需要遍历整个数组，比较左右两个子数组的元素，合并的时间复杂度是 **`O(n)`**，即线性时间。

 递推公式的解释

因此，归并排序的总时间复杂度 \( T(n) \) 就等于：
- 分解左右两部分的时间：`2T(n/2)`
- 加上合并两部分的时间：`+ n`

所以，**最终的递推公式为**：$T(n) = 2T\left(\frac{n}{2}\right) + n$


使用主定理求解时间复杂度

通过**主定理**（Master Theorem），可以求得该递推公式的解为 **\( T(n) = O(n \log n) \)**。这就是归并排序的时间复杂度。

##### 递归公式

- 每次递归将列表分成两半，所以递归公式为：
  
  $T(n) = 2 \cdot T\left(\frac{n}{2}\right) + n$
  
- 其中，`2 * T(n/2)` 表示两个子列表的排序过程，`+ n` 表示合并两个子列表所需的线性时间。

##### 递归关系 T(n) 的分析

这份笔记详细介绍了递归关系 \( T(n) \) 的展开过程，使用递归代换的方式逐步推导出结果。目标是分析该递归函数的增长趋势。

##### 初始条件与递归关系

给定递归关系：
$T(n) = 2T\left(\frac{n}{2}\right) + n$
以及基准条件（Base Case）：
$T(1) = 1$

##### 递归展开步骤

##### 第一步展开

将 $T(n) = 2T\left(\frac{n}{2}\right) + n$ 带入一次递归：

1. $T(n) = 2\left[T\left(\frac{n}{2}\right)\right] + n$
2. 再将 $T\left(\frac{n}{2}\right)$ 按相同关系继续展开：

$T(n) = 2\left[2T\left(\frac{n}{4}\right) + \frac{n}{2}\right] + n$

3. 简化表达式后得到：
   $= 2^2 T\left(\frac{n}{4}\right) + 2 \cdot \frac{n}{2} + n = 2^2 T\left(\frac{n}{4}\right) + n + n$

##### 第二步展开

继续递归展开 $T\left(\frac{n}{4}\right)$：

1. 将上一步结果带入递归关系：
   $T(n) = 2^2 \left[2T\left(\frac{n}{8}\right) + \frac{n}{4}\right] + n + n$
2. 展开后得：
   $= 2^3 T\left(\frac{n}{8}\right) + 3n$

##### 第三步展开

进一步递归展开 $T\left(\frac{n}{8}\right)$：

$T(n) = 2^3 \left[2T\left(\frac{n}{16}\right) + \frac{n}{8}\right] + 3n$
简化后得：
$= 2^4 T\left(\frac{n}{16}\right) + 4n$

##### ==一般化==

> [!NOTE]
>
> 观察递推过程得到k的一般化. 是k和n的函数. 此时k不是时间复杂度 ,是达到终止条件的次数,即停止递归, 还要回代进T, 即真正的时间复杂度.

通过观察递推过程，我们发现每一步的形式如下：

$T(n) = 2^k T\left(\frac{n}{2^k}\right) + kn$

##### 终止条件

当 $\frac{n}{2^k} = 1$ 时，即 $n = 2^k$，我们达到基准条件：
$T(1) = 1$

于是 $k = \log_2 n$。

##### 代入基准条件并求解

> [!NOTE]
>
> 回代

将 $k = \log_2 n$ 代入一般形式：

$T(n) = 2^{\log_2 n} T(1) + n \log_2 n$

因为 $2^{\log_2 n} = n$，所以得到：

$T(n) = n + n \log_2 n$

最终结果是：
$T(n) = O(n \log n)$

##### 总结

通过递归展开和基准条件的求解，我们得到了递归关系 $T(n) = 2T\left(\frac{n}{2}\right) + n$ 的复杂度为 $O(n \log n)$。

- **时间复杂度**：$O(n \log n)$
- **描述**：归并排序是一种分治法，通过递归地将数组分成两半，然后合并排序好的部分。
- **适用情况**：适合大规模数据的排序操作。
